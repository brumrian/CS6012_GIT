{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww28600\viewh18000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \

\f1\b Rian Brumfield\
November 23, 2021\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0
\cf0 Sorting Algorithms Analysis Document
\f0\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
Note that if you use the same seed to a Java Random object, you will get the\
same sequence of random numbers (we will cover this more in a lab soon). Use\
this fact to generate the same permuted list every time, after switching\
threshold values or pivot selection techniques in the experiments below. (i.e.,\
re-seed the Random with the same seed)\
\
1. Who are your team members?\
\

\f1\b Malila Freeman
\f0\b0 \
\
2. Mergesort Threshold Experiment: Determine the best threshold value for which\
mergesort switches over to insertion sort. Your list sizes should cover a range\
of input sizes to make meaningful plots, and should be large enough to capture\
accurate running times. To ensure a fair comparison, use the same set of\
permuted-order lists for each threshold value. Keep in mind that you can't\
resort the same ArrayList over and over, as the second time the order will have\
changed. Create an initial input and copy it to a temporary ArrayList for each\
test (but make sure you subtract the copy time from your timing results!). Use\
the timing techniques we already demonstrated, and be sure to choose a large\
enough value of timesToLoop to get a reasonable average of running times. Note\
that the best threshold value may be a constant value or a fraction of the list\
size. Plot the running times of your threshold mergesort for five\
different threshold values on permuted-order lists (one line for each threshold\
value). In the five different threshold values, be sure to include the\
threshold value that simulates a full mergesort, i.e., never switching to\
insertion sort (and identify that line as such in your plot).\
\
\
\
3. Quicksort Pivot Experiment: Determine the best pivot-choosing strategy for\
quicksort. (As in #2, use large list sizes, the same set of permuted-order lists\
for each strategy, and the timing techniques demonstrated before.) Plot the\
running times of your quicksort for three different pivot-choosing strategies\
on permuted-order lists (one line for each strategy).\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b \cf0 {{\NeXTGraphic Pivot Selection Analysis Graph.png \width12000 \height7420 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
The most effective pivot selection is the Median Pivot selection. In this option, the median between the first, middle, and last elements is chosen as the pivot. \
The second most effective pivot selection is always choosing the first element. This is only due to the fact that the ArrayList to be sorted was shuffled and in no sorted order. If the ArrayList were already sorted, this pivot  selection would result in the worst case.\
The least effective pivot selection was the Random pivot, I think due to its inconsistency, sometimes choosing effective pivots and sometimes choosing really ineffective pivots. Although, it is notable that with a properly shuffled arrayList, the first pivot could effectively work the same as the Random pivot.\
\
\

\f0\b0 \
\
\
4. Mergesort vs. Quicksort Experiment: Determine the best sorting algorithm for\
each of the three categories of lists (best-, average-, and worst-case). For\
the mergesort, use the threshold value that you determined to be the best. For\
the quicksort, use the pivot-choosing strategy that you determined to be the\
best. Note that the best pivot strategy on permuted lists may lead to O(N^2)\
performance on best/worst case lists. If this is the case, use a different\
pivot for this part. As in #2, use large list sizes, the same list sizes for\
each category and sort, and the timing techniques demonstrated before. Plot\
the running times of your sorts for the three categories of lists. You may plot\
all six lines at once or create three plots (one for each category of lists).\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 {{\NeXTGraphic MergeSort vs. QuickSort Algorithm Analysis.png \width18700 \height11560 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \

\f1\b In the graph above, MergeSort times are so similar compared to the Quicksort data that all three appear to be the same line on the graph.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b0 \cf0 \
\
\
\
\
5. Do the actual running times of your sorting methods exhibit the growth rates\
you expected to see? Why or why not? Please be thorough in this explanation.\
\
Team members are encouraged to collaborate on the answers to these questions\
and generate graphs together. However, each member must write and submit\
his/her own solutions.\
\
Upload your solution (.pdf only) through Canvas.\
\
}